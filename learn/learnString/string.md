# 字符串
2. 字符串编码规范和Unicode码点
    * Unicode标准基本单位不是字符，而是码点，在Go中用rune表示
        * 实际上是另一个更加通用的、针对书面字符和文本的字符编码标准。它为世界上现存的所有自然语言中的每一个字符，都设定了一个唯一的二进制编码
    * 码点值的编码方式: UTF-8
    * ASCII编码规范: 单字节字符编码（很多字符没有定义，比如汉字）
    * UTF-8的编码格式(关心字符如何存储？如何划分字符边界)
        * 编码格式主要关注的是字符与字节序列之间的转换方式
        * UTF-8是一种可变宽的编码方案(使用1~4个字节来表示一个字符，程序如何知道当前的字符是多少位呢？)
        * 一开始使用的是定长编码，统一按照unicode字符中最长的字符进行存储，高位进行补0，这样比较浪费内存
        * 如果使用可变长编码，UTF-8是如何划分字符边界的呢？
            * 解码时会把标识位去掉，剩下的位组成编号，找到对应的字符
            * 编码时会先找到对应的字符的编号，选择按照对应的模板来表示该字符，把二进制数字填入模板中
                * 0??????? -> [0,127] -> 一字节
                    * 如果最高位是0，表示占用一个字节
                * 110????? 10?????? -> [128, 2047] -> 两字节
                    * 如果最高位是110，表示占用两个字节
                * 1110???? 10?????? 10?????? -> [2048, 65535] -> 三字节
                    * 如果最高位是1110，表示占用三个字节

# 关于string一些问题
1. 一个string类型的值在底层是如何表达的？
    * 一个string由一系列相对应的Unicode的码点的UTF-8编码值来表示
    * string: 
        ```
        type stringStruct struct {
            str unsafe.Pointer
            len int
        }  // 64位机器上，结构体就是 8 + 8 = 16 字节
        ```
        * C是用\0表示字符串结尾，go使用长度表示字符串结尾
        * go认为string是不能修改的，所以存放在内存的只读空间
    * string可以转换成哪些数据类型？（需要注意是否需要复制数据）

        ```
        // string to []byte
        s1 := "hello"
        b := []byte(s1) // 拷贝s1的内容，放到slice中

        // []byte to string
        s2 := string(b)
        ```
    * 字符串的默认值不是nil，而是""

2. 使用for-range时注意
    * 遍历此字符串中的码点
    ```
    // 此处[]byte转换不需要做复制
    for i, b range []byte("hello, world"){
        fmt.Printf("The byte at index %v: 0x%x \n", i, b)
    }
    ```
3. 语法糖
    * append(hello, world...)