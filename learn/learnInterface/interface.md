
1. 接口类型
    * 值包裹: 接口类型的值可以用来包裹非接口类型的值


    * 通过值包裹，实现反射和多态
    * 接口元素
        * 方法元素
        * 类型元素
            * 类型名称
            * 类型字面表示形式
            * 一个近似类型
            * 一个类型并集
    ```
    type Error interface {
        Error() string
    }

    // 所有底层类型为[]byte的类型组成
    type AnyByteSlice = interface {
        ~[]byte
    }

    // 内嵌了一个类型并集？？？
    type UnSigned interface {
        uint | uint8 | uint16 | uint32 | uint64 | uintptr
    }
    ```

2. 多态：函数与接口类型
    * func(interface{})interface{}
    * 如果没有接口类型，函数只能处理一种数据，返回一种数据
    * 使用接口类型时，函数可以处理一类数据，返回一类数据（多态）
    * 接口类型背后一定有具体类型，一般情况我们不需要知道，当我们把具体类型赋予接口类型后，不要再想着具体类型了
    ```
    func DoX(x interface{}){
        // 实现该接口的具体类型的值可以赋值给接口类型的变量
        // 接口实际上添加限制

        return x
    }

    func ReturnError(s string) error{
        // 根据输入不同，可以返回实现error接口的不同动态类型
        // 可以返回具体值，或者该接口类型的值
        // 不过函数整体返回的一定是一个接口类型的值
        return fmt.Errorf(s)
    }
    ```

3. 反射（reflection）
    * 通俗地将，反射让我们能看到包裹了什么（接口能让我们把东西包裹起来）
    * 类型断言
        * 和接口相关的类型转换
            * 非接口值 -> 接口值
            * 接口值 -> 接口值
            * 接口值 -> 非接口值
            * 接口值 -> 接口值（前面的接口值的类型并未实现后面的接口类型，但是动态值实现了）
        * 断言表达式: i.(T)
            * T是一个非接口类型
                * i的动态类型存在并且和T为同一类型
            * T是一个接口类型
        * 对于一个动态类型为T的接口i，方法调用i.m(...)等价于i.(T).m(...)
        * type-switch语句
            * 根据类型来执行不同的语句
        ```
        switch v := x.(type) {
        case TypeA:
            do something
        case TypeB:
            do something
        default:
            do something
        }
        ```

4. 空接口值 and nil接口值
    * 空接口值是一种接口类型（方法集为空）
    * nil接口值是接口当前的一种状态，什么也没包裹

5. 接口值的比较
    * 非接口值 vs 接口值（前提: 非接口值可以隐式转换成接口值）
    * 接口值 vs 接口值（实际上比较的是动态类型和动态值）
    * 比较步骤
        * 如果其中一个接口值是nil，判断另外一个是否也是nil
        * 动态类型不一样，结果为false
        * 动态类型一致，比较动态值

