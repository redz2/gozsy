# 指针
* 指针 vs 值的地址
    * 内存地址用来定位一段内存
    * 指针本身也是一段内存，只不过内存中保存的是一个内存地址（prt -> address）
        * 每个变量实际上就是一个内存地址，解引用其实就是得到值的地址
    * 值的地址
        * 值的直接部分的内存起始地址

* 什么是指针？
    * 指针是Go中的一种类型分类（Kind）

* 指针的类型和值
    * 指针类型的底层类型\*T，那么基类型为T
    * 无名指针类型可读性更高（一般不声明具名指针类型）
    * 指针类型的零值字面量使用nil来表示
    ```
    *int 一个基类型为int的无名指针类型
    **int 一个基类型为*int的无名指针类型

    type Ptr *int 一个基类型为int的具名指针类型
    ```

* 如何获取一个指针的值？
    * &p
    * new(int)
    ```
    var x = 10
    var p *int  // 地址是啥？类型是啥？
    p = &x      // 将x的内存地址的副本赋值给p
    *p += 20    // *p 访问指针存储的内存地址的值，解引用的优先级很高
                // x 访问x变量自己内存地址的值
                // 解引用一个nil指针会panic

    var y = x   // 创建新的变量y，将x的副本赋值给y

    int_p := new(int) // 开辟一块内存，用来存放int，并返回内存地址
    ints_p := new([]int) // 开辟一块内存，用来存放slice，返回slice的内存地址（少做了啥？忘记分配slice的底层数组了）
    ints_p2 := make([]int,2,3) // 开辟一块内存，用来存放slice，并初始化底层数组，返回slice
    ```

* 为什么需要指针？
    * 为了直接修改变量的值
        * Go所有的赋值（包括函数调用时传参）都是值赋值
        * 指针提供了一种间接的途径来访问和修改值

* Go中返回一个局部变量的地址是安全的
    * 因为Go支持垃圾回收
    ```
    func NewInt(){
        a := 3
        return &a
    }
    ```

* 几个有点绕的问题？
    * 什么叫类型相同？pa1和pa2
    * 什么叫底层类型相同？pa1和pa4
    * 什么叫基类型的底层类型相同？pa1和pa3
    ```
    type MyInt int
    type Ta *int
    var pa1 *int
    var pa2 *int
    var pa3 *MyInt  // 底层类型为*MyInt，*int不相同
    var pa4 Ta
    ```

* Go指针的限制
    * Go指针不支持算术运算
        * 无法和C语言一样使用指针操作slice和map
    ```
    *(p++) // 不合法
    ```
    * 一个指针类型的值不能随意转换成另一个指针类型的值，那何时可以转换？
        * 类型相同转换个P啊
        * 指针的底层类型一致时可以: 
        * 指针都是无名类型，并且基类型的底层类型一致: *int 和 *MyInt
    * 一个指针不能随意和另外一个指针值进行比较，指针值何时可以比较？
        * 两个指针类型相同: pa1 == pa2
        * 其中一个可以隐式转换成另外一个指针的类型，也就是说底层类型一致，并且至少有一个是无名指针类型: pa0 == pa1（Ta和\*int64类型不同，但是底层类型都是\*int64）
        * 其中有且只有一个是不确定的nil标识符: pa == nil
    * 一个指针值是否可以赋值给其他指针，和是否可以比较条件一样
        ```
        type MyInt int64
        type Ta    *int64
        type Tb    *MyInt   // *MyInt 和 *int64 是不同的类型，底层类型也不同
                            // 但是他们的基类型的底层类型相同

        var pa0 Ta
        var pa1 *int64
        var pa2 *int64
        var pb0 Tb
        var pb1 *MyInt
        
        pa0 == pa1  // 底层类型都是*int64
        pb0 == pb1  // 底层类型都是*MyInt
        pa0 == nil
        pa1 == nil
        pb0 == nil

        pa0 == pb0     // *int64 和 *MyInt 底层类型不同
        pa0 == Tb(nil) // 底层类型不一致

        // *MyInt的值可以显式转换成*int64，因为都是无名类型，并且基类的底层类型都是int64

        // Ta的值不能直接转换成Tb，因为都是具名类型，类型不同，但可以间接转换
        // ta(具名类型) -> *int64(无名类型) -> *MyInt(无名类型) -> Tb(具名类型)
        Tb((*MyInt)((*int64)(ta)))
        ```
    * 如何通过unsafe.Pointer将指针转换位uintptr后进行操作？