# Go语言的类型系统
## 问题
1. 什么叫类型？
    * 类型可以看作是值的模板，值可以看作类型的实例 -> 确定内存布局
2. 什么叫值？
    * 一个类型的一个实例称为此类型的一个值
    * 任一类型的所有值的尺寸都是相同的，一般用字节来表示，rune32尺寸为4

## 类型（Type）
1. 基本类型(预声明类型、内置类型)
    * 字符串: string
    * 布尔: bool
    * 数值类型: int,float,complex
        * byte是uint8的类型别名，rune是int32的类型别名
        ```
        type byte = uint8    // 类型别名: byte和uint8完全等价，byte只是一个名称，更明确地表示这代表一个字符
        type MyInt int       // 自定义类型: MyInt和int完全是两个类型，只是底层数据存储一样（kind一样）
        ```
2. 组合类型(自定义类型)
    * 指针类型: *T
    * 结构体类型:
    ```
    struct {
        name string
        age  int
    }
    ```
    * 函数类型: func(int,int)int
    * 容器类型
        * 数组: [5]T
        * 切片: []T
        * map: map[Tkey]T
    * 通道类型
    ```
    chan T
    chan<- T
    <-chan T
    ```
    * 接口类型 - 反射和多态
    ```
    type interface {
        Method0(string)int
        Method1()(int, error)
    }
    ```
3. 类型种类（what is Kind？）
    * Name: 类型名称为User
    * Kind: 类型种类为struct(go一共26种类型种类)
    ```
    type User struct {
        name string
        age  int
    }
    ```
4. 类型定义（what is type？类型定义声明）
    * 使用type关键字定义一个“新”类型
    ```
    type NewTypeName SourceType // 这是两个类型，底层类型一致，可以显式类型转换
    ```
    * 具名类型和无名类型
        * 具名类型: type MyInt int
        * 无名类型: 一定是组合类型（反之则未必）
        ```
        x := struct{
            name string
        }{
            "shaw",
        }
        ```
        * 这说明一个类型一定有种类，但不一定会有名字
    * 类型别名
        * byte和uint8是相同的类型
    * 底层类型（比较重要的概念）
        * 一个内置类型的底层类型是自己: int
        * 一个无名类型的底层类型是自己: 
        * 新声明的类型和源类型共享底层类型: type MyInt int
        * 如何溯源一个类型的底层类型？
            * 遇到内置类型或无名类型结束
            ```
            type MyInt int  // 底层类型为int
            type MyInts []MyInt // 底层类型为[]MyInt（slice）
            ```
        * 底层类型有啥用？
            * 类型转换、赋值、比较
        * 类型转换
            * 何时可以隐式类型转换
                * 类型T实现了接口I，T可以隐式转换成I
                * 短变量赋值
            * 何时可以显式类型转换
                * 类型不同但相互兼容？？？
                * resultType := Type(expression)
                    * T(v)
        * 类型断言
            * 将一个接口类型转换成实际的数据类型
            * resultOfType, boolean := expression.(Type)  // 安全类型断言
            * fmt打印接口类型，会识别出动态类型，并打印动态类型的值

## 值（Value）
1. 值在代码中以什么形式呈现？
    * 字面量
        * 通俗点说，字面量只是代码中的一种写法而已
        * 常见类型的字面量写法
            * bool -> true/false
            * string
                * 直白 `abc\n`
                * 解释 "abc\n" or "\141\142\143"
                * 零值: "" or ``
            * int(以下只是数字不同进制的写法，都是数字)
                * 十六进制(hex): __0x17__ 0X17
                * 十进制(decimal): 17
                * 八进制(octal): __017__ 0o17 0O17
                * 二进制: __0b1001__ 0B1001
            * 数字字面量分段提高可读性
                * 0x1_000_000
            * rune(字符)
                * 可以用值表示: 'a' == 97 
                * 字符: 'a'
                * 变种表示: 
                    * 八进制 '\141'
                    * 十六进制 '\x61'
                    * '\u0061'
                    * 其他特殊字符
                        * '\t'
                        * '\a'
                * 单引号和双引号的区别还是很大的

        * 基本类型的字面量都是无名常量或者字面常量
            * 字面量都属于 __类型不确定__ 值（字面量本身没有类型，比如32可以是int，也可以是int32，也可以是int64）
            * 虽然字面量本身没有类型，但存在 __默认类型__，编译器会认为128就是个int类型（类型推断）
            ```
            // 这里存在类型推断
            a := 97  // int
            b := 'a' // int32
            c := "a" // string
            ```
            * 类型不确定常量的 __显式转换__ T(v): 因为字面量类型不确定，如何让类型变成确定的呢？
                * 有时会写成: (T)(v)
            ```
            int(1.23) // 非法转换
            int32(12)
            string(65)
            ```
        * 指针类型、通道类型、接口类型没有字面量表示形式
        * 值分为类型确定的和类型不确定的
    * 变量
        * 变量是运行时存储在内存中可以修改的具名的值
        * 所有变量都是类型确定值！！！
        * 变量都是可寻址的
        * 变量声明
            * 标准变量声明: 给编译器提供两个关键信息: 类型是啥？值是啥？
            * 简短变量声明: 只提供其中一个。要么提供初始值，就能推断类型；要么提供类型，就能初始化为类型对应零值
            ```
            var s string = "Go"
            var website = "baidu"       // 类型推断可以视为隐式类型转换
            var a int                   // 初始化为零值（声明变量总是会初始化，所以一个变量总是有值的？）
            var arr [5]int              // 初始化后的值: [0,0,0,0,0]
                                        // 这个python的感觉不太一样啊？长度就不同 a = []
            ```
            * 短变量声明
            ```
            c := 1
            ```
        * 变量赋值(给盒子塞一个东西)
            * 纯赋值语句 -> 变量已经有了，修改变量的值
                * 左边必须是一个可寻址的值（常量是不可寻址的）、一个映射元素、一个空标识符
                ```
                *ptr = "xxx"
                ```
                * x = y 能赋值的前提: x是可修改的，y和x类型一致，或y可以隐式转换为x
                
            * 短变量声明
            * 函数传参
    * 具名常量
        * 具名常量声明(常量可以没有类型，也可以有类型，常量不可寻址)
        ```
        const Pi = 3.14159      // pi := 3.14159
        const X float32 = 3.14  // 类型确定具名常量

        const (
            X float32 = 3.14
            Y                   // 自动补全 Y float32 = 3.14
            Z
        )

        const (                 // iota初始为0，出现在第几个，就是几
            k = 3 // 在此处，iota == 0
            J = 3 // 在此处，iota == 0
            m float32 = iota + .5 // m float32 = 2 + .5
            n                     // n float32 = 3 + .5
        )
        ```
        * 常量声明可以看作是增强型的C语言中的#define宏。 在编译阶段，所有的标识符将被它们各自绑定的字面量所替代
    * 表达式
2. 值部（更关注在内存中如何存储）
    * Go类型分为两大类别（按内存分布分）
        * 每个值在内存中只分布在一个内存块上的类型（直接值部）
            * bool
            * int
            * ptr
            * struct
            * array
        * 每个值在内存中会分布在多个内存块上的类型（直接值部 -> 底层间接值部）
            * slice
            * map
            * channel
            * func
            * interface
            * string(值类型)
            ```
            type _map *hashtableImpl
            type _channel *channelImpl
            type _function *functionImpl

            type _slice struct {
                elements unsafe.Pointer // 引用着底层的元素
                len      int            // 当前的元素个数
                cap      int            // 切片的容量
            }

            type _string struct {
                elements *byte // 引用着底层的byte元素
                len      int   // 字符串的长度
            }

            type _interface struct {
                dynamicType  *_type         // 引用着接口值的动态类型
                dynamicValue unsafe.Pointer // 引用着接口值的动态值
            }
            ```
        * 相关问题
            * 什么是引用类型呢？这个概念没有必要存在（使用“指针持有者类型”来替代引用类型）
                * 包含指针的一定是引用类型吗？一般来说是的，但string就是值类型（编译器不让修改）
            * 赋值时，底层间接值部不会被复制（只复制直接值部，共享底层间接值部）
                * 这就是为啥说引用类型的赋值是浅拷贝的原因，go中没有浅拷贝、深拷贝这些概念，如果一定要有，都是浅拷贝
                * 字符串和接口可能不太一样，接口的动态值是只读的，字符串也是只读的，即使共享底层数据，因为无法修改，就不存在传引用的修改值的问题
    * 值尺寸
        * unsafe.Sizeof: 一般说的是直接部分的字节数，就是类型的尺寸
    * 一个值的具体类型和具体值
        * 非接口类型就是值的类型和值本身
        * 接口类型具体类型和具体值指的是动态类型和动态值

## nil标识符
1. nil是一个预声明的标识符（实际上nil __只是__ 一个标识符，可以表示多种类型的零值，但并不是真正的零值）
    * 可以表示以下种类（Kind）的类型的零值（虽然都可以用nil来表示零值，但不同类型的零值是不同的，所以有这样的疑惑，为啥都==nil，但是却不相同）
        * 指针
        * map
        * slice
        * func
        * channel
        * interface
    * nil没有默认类型（不是没有类型）
        * true/fasle: bool
        * iota: int
        * 必须为编译器提供信息能判断出nil的类型
    * 不同种类的类型的nil值的内存大小不同
        * 同一类型的nil和非nil的值内存大小是一致的
            * 通过unsafe.Sizeof()可以证明nil和非nil的内存结构一致
        * 不同种类的nil无法比较(因为类型不同)
            * (interface{})(nil) == (*int)(nil)  // 可以比较，但是不相等
                                                 // 前者是一个空接口，后者是一个非空接口（包裹了一个*int类型，但值为nil）
        * map、func、slice不支持比较，只能和nil进行比较

2. nil: 提供了一个关键词用来表示一些类型的零值
    * 声明内置类型的变量，如果不进行初始化，默认初始化为该类型的零值
        * 零值初始化机制
            * 好处: 确保变量总是有一个有效值
            * 坏处: 无法判断是未初始化的值，还是就是为0
    * 不过interface、channel等类型没办法表示零值，所以就用nil这个关键词来表示

## 泛型