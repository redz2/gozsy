# GPM
1. goroutine: 协程，称为G
    * G可以看成是一个个任务
2. processor: 逻辑处理器，称为P
    * P其实就是G的队列
    * P和M会绑定
    * 如果P中的G发生阻塞，该P会和M解绑，创建新的M，重新绑定（原来的M处于阻塞状态，等到阻塞结束，重新放入P队列）
        * 当执行到time.Sleep时，调用gopark切换为其他G（说明对timer也是有优化的）
        * 把该G放回队列，记录一个timer的时间
        * 每次调度，会检查是否有timer到期
    * 网络请求和IO操作导致G阻塞，Go提供了NetPoller来处理，防止因为这些系统调用阻塞M
        * 这些G会被放到网络轮询器中异步处理网络请求
        * M可以继续执行其他G（相对于上面一条进行优化，不需要创建新的M）
3. machine: 系统线程，称为M
    * 实际执行任务

## GPM模型解决的问题
1. 实现少量内核线程支撑大量goroutine的并发运行
2. 通过NetPoller、sysmon帮助Go程序减少线程阻塞，充分利用已有的计算资

