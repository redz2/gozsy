# sync.Mutex
1. 相比于 Go 语言宣扬的“用通讯的方式共享数据”，通过共享数据的方式来传递信息和协调线程运行的做法其实更加主流
    * 竞态条件: 一旦数据被多个线程共享，那么就很可能会产生 __争用和冲突__ 的情况，这往往会破坏共享数据的一致性
    * 同步: __控制多个线程对共享资源的访问__ 来确保多个并发运行的线程对这个共享资源的访问是完全串行的（__锁住共享资源__）
    ```
    mu.Lock() // 拿锁，拿不到锁会阻塞
    _, err := writer.Write([]byte(data))
    if err != nil {
        log.Printf("error: %s [%d]", err, id)
    }
    mu.Unlock() // 还锁
    ```
    
2. 互斥锁(sync.Mutex)
    * sync.Mutex是结构体类型，是值类型
        * 把Mutex传给函数，传的是副本（是一把全新的锁）
    * sync.Mutex用来保护一个或者一组临界区
        * 通过互斥锁给代码创建一个临界区（保证同一时刻只有一个goroutine能够执行）

3. 读写锁(sync.RWMutex)
    * 针对写: Lock/Unlock
    * 针对读: RLock/RUnlock
    * 多个写操作不能同时进行，读操作和写操作不能同时进行，多个读操作可以同时进行