# 类型
1. 变量
    * 变量是一段或多段用来存储数据的内存
        * 变量总是有固定的数据类型，我们只能修改值，无法修改类型
        * 定义变量: 变量一定会初始化，如果不提供，会初始化成零值

    * 如何声明变量？(类型推断，在程序初始化时由程序确定)
    ```
    var x int    // 自动初始化为零值
    var y = 2    // 自动推断类型
    var z []int  // 引用类型零值为nil，必须通过make创建slice

    var a,b int
    var q,w = 100, "abc"

    var (
        a,b int
        q,w = 100, "abc"
    )
    ```
    * 简短模式(短变量声明): 最少有一个新变量被定义
    ```
    a, b := 100, "abc"
    ``` 
    * 多变量赋值
    ```
    x, y := 1, 2
    x, y = y+3, x+2 // 先计算出右值
    ```

    * 变量赋值的本质
        * go vs python
            * python: 先创建对象，然后把变量作为标识，指向该变量（a=b 一定是b指向的对象，又加了一个标签）
                * python的变量不是盒子，是标签纸
            * golang: 先创建变量，然后把值放到变量中（a:=b 一定是b创建副本，赋值给a）
                * golang的变量就是盒子
        ```
        b := "hello"
        a := b

        var p Pet // 接口类型未初始化时是nil
        p = Dog{}
        ```
2. 命名
    * 建议
        * 驼峰
        * 局部变量优先短名
    * 空标识符
        * 表达式左值，无法读取内容
3. 常量
    * iota只能在const中
    * 只读
    * 编译器预处理阶段展开，作为指令数据使用
    * 不会分配内存
    ```
    const (
        GREEN = iota  // 默认类型int
        RED
        YELLO = 100   // 中断
        BLACK         // 与上一行一样
        ORANGE = iota // 显式恢复
    )
    ```
4. 进制
    ```
    字面量表示法
    二进制: 0b1100100
    八进制: 0144
    十进制: 100
    十六进制: 0x64
    
    fmt.Printf("%b %o %d %x", 100, 100, 100, 100)
    ```
5. 引用类型
    * 未初始化值时为nil
        * 指针只是引用类型中的一种
        * 引用类型其实是特殊的struct，golang对其有特殊处理，比如初始化时设置为nil，其实和有值时内存布局一致
            * 这样子使用起来更简单，但是不直观
        * nil是零值写法，本身没有默认类型（不过可以表示内存布局不一致的各种引用数据类型的零值）
    * new 和 make 的区别？
        * new: 分配内存，返回指向该内存的指针
        * make: 用于为map，slice，channel分配和初始化内存，返回类型本身（slice是引用类型，但他不仅仅是一个指针这么简单）
        ```
        var i *int = new(int)
        var s []int = make([]int, 3)
        ```
6. 类型转换
    * 何时可以类型转换？

7. 自定义类型
    * 如何定义自定义类型
    ```
    type flags byte

    // 组
    type ( 
        user struct {  // 结构体
            name string
            age  int
        }
        event func（string) bool // 函数
    )
    ```
    * 即便重新定义基础类型，也只表示有相同的底层数据结构，两者间不存在任何关系
    ```
    type data int
    var x data = 10
    var y int = data // 错误，无法赋值

    var z int = 10
    fmt.Println(x==z) // 错误，无法比较
    ```
