# 数组和切片
## 数组
1. 数组的长度是固定的
    * [1]string 和 [2]string 是两个不同类型的数组
    * 值字面量
        * [3]string{"a", "b", "c"}
2. 数组是一个容器，每个item都可以修改
    * 字符串：可以认为是一个特殊的不可变的数组
    ```
    s := "shaw"
    len(s) // 字节数
    len([]rune(s)) // 字符数
    ```

## 切片
0. 切片的底层结构
    * data|len|cap
    * var ints []int // nil|0|0
        * 声明slice后，需要告诉他底层数组是啥，长度是多少，容量是多少
    * var ints []int = make([]int, 2, 5) // nil|2|5
        * ints = append(ints, 1) // 初始化时前两位已经是0了，所以再添加一个就是第3个，相应的slice的长度变成3了
    * ps := new([]string)
        * ps就是一个地址，并没有分配底层数组，尽量用make初始化
        * (*ps)[0] = 1     // 操作是不允许的
        * \*ps = append(*ps, 1)   // append会创建底层数组，这个操作是可以的
    * 切片共用底层数组
        * 切片之间是会相互影响的
        * 如果扩容时发现底层数组cap不够，会重新创建新的底层数组，将之前的数据拷贝过来（此时就和之前的底层数组彻底没关系了）
1. 切片是可变长的，基于数组的
    * 切片的长度可以自动地随着其中元素数量的增长而增长，但不会随着元素数量的减少而减小
    * 值字面量: []string{"a", "b", "c"}
2. 切片属于引用类型
    * 可以把切片看做是对数组的一层简单的封装，因为在每个切片的底层数据结构中，一定会包含一个底层数组
    * 有一个窗口，你能通过这个窗口看到一个数组，但是不能够看到数组的全部元素，只能看到连续的一部分元素
3. 切片容量 -> cap(l)
    * 数组的容量等于其长度
    * 一个切片的容量可以被看作是透过这个窗口最多可以看到的底层数组中元素的个数（切片窗口无法向左扩展，只能向右）
    ```
    s3 := []int{1, 2, 3, 4, 5, 6, 7, 8}
    s4 := s3[3:6]
    fmt.Printf("The length of s4: %d\n", len(s4))
    fmt.Printf("The capacity of s4: %d\n", cap(s4))
    fmt.Printf("The value of s4: %d\n", s4)
    ```
4. 切片长度 -> len(l)
5. 切片声明
    * 最大的区别在于是否进行了初始化
    ```
    a := make([]byte, 5) -> 指针不为nil，有底层数组，底层数组是零值
    b := []byte{} -> 指针不为nil，有底层数组，底层数组是零值
    var c []byte -> 空切片，指针为nil，没有底层数组，未初始化
    ```
6. 切片扩容（go自己会扩容），可以把slice理解为一种“动态数组”
    * 预估容量
        * 如果切片容量小于1024，扩容时cap\*2；如果切片容量大于1024，扩容时cap\*1.25(增加四分之一)
        * 如果扩容后，没有触及原数组的容量，切片中指针还是指向原数组；如果超过原数组，go开辟一块新内存，把原数组的值拷贝过来
    * 计算出字节数
    * 向OS内存管理系统申请内存
        * 内存管理系统会提前创建一些常用大小的内存块
        * 比如go申请120字节的内存，而内存管理系统只有128字节的，就会直接给go拿去用

7. slice相关问题
    * s = append(s, 1)   // 为啥需要赋值？因为append可能会导致底层数组扩容，如果超过cap，会创建新的底层数组
    ```
    a := make([]int, 3, 4)
	a[0] = 1
	a[1] = 2
	a[2] = 3
	var b = a[:]
	// a = append(a, 4)        // 未更换底层数组
	a = append(a, 4, 5, 6, 7)  // 更换底层数组
	a[0] = 1000
	fmt.Println(a)
	fmt.Println(b)             // 是否创建新数组对于b来说差别很大，这容易让人困惑，那如果要用一样的切片咋办？
                               // 语法层面缺乏一致性
    ```

