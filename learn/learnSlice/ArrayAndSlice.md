# 数组和切片
## 数组
1. 数组的长度是固定的
    * [1]string 和 [2]string 是两个不同类型的数组
    * 值字面量
        * [3]string{"a", "b", "c"}
2. 数组是一个容器，每个item都可以修改
    * 字符串：可以认为是一个特殊的不可变的数组
    ```
    s := "shaw"
    len(s) // 字节数
    len([]rune(s)) // 字符数
    ```

## 切片
1. 切片是可变长的，基于数组的
    * 切片的长度可以自动地随着其中元素数量的增长而增长，但不会随着元素数量的减少而减小
    * 值字面量
        * []string{"a", "b", "c"}
2. 切片属于引用类型
    * 可以把切片看做是对数组的一层简单的封装，因为在每个切片的底层数据结构中，一定会包含一个底层数组
    * 有一个窗口，你能通过这个窗口看到一个数组，但是不能够看到数组的全部元素，只能看到连续的一部分元素
3. 切片容量 -> cap(l)
    * 数组的容量等于其长度
    * 一个切片的容量可以被看作是透过这个窗口最多可以看到的底层数组中元素的个数（切片窗口无法向左扩展，只能向右）
    ```
    s3 := []int{1, 2, 3, 4, 5, 6, 7, 8}
    s4 := s3[3:6]
    fmt.Printf("The length of s4: %d\n", len(s4))
    fmt.Printf("The capacity of s4: %d\n", cap(s4))
    fmt.Printf("The value of s4: %d\n", s4)
    ```
4. 切片长度 -> len(l)
5. 切片声明
    * 最大的区别在于是否进行了初始化
    ```
    a := make([]byte, 5) -> 指针不为nil，有底层数组，底层数组是零值
    b := []byte{} -> 指针不为nil，有底层数组，底层数组是零值
    var c []byte -> 空切片，指针为nil，没有底层数组，未初始化
    ```
6. 切片扩容（go自己会扩容），可以把slice理解为一种”动态数组“
* 如果切片容量小于1024，扩容时cap*2；如果切片容量大于1024，扩容时cap*1.25
* 如果扩容后，没有触及原数组的容量，切片中指针还是指向原数组；如果超过原数组，go开辟一块新内存，把原数组的值拷贝过来

## 变量赋值
* go中所谓的传值还是传引用，只需要看被传递的值的类型就可以
    * go变量赋值，是值拷贝
        * 完全可以把变量看成是盒子 
    * python变量赋值，是贴标签
        * 变量只是标签，对象才是盒子
